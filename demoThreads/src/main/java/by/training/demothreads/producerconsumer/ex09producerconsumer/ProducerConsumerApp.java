package by.training.demothreads.producerconsumer.ex09producerconsumer;

/**
 * b)deadlock
 * <p>
 * Нередко работа одного потока зависит от другого. Например, есть классическая задача "Производители и потребители"
 * ("Producer-Consumer"), в которой производители производят товар и доставляют его в магазин, а потребители покупают
 * этот товар. При этом потребители могут купить товар только тогда, когда производители произвели этот товар. То есть
 * в данном случае есть потоки производителей и потоки потребителей, и они должны как-то взаимодействовать. Есть еще
 * ряд подобных задач, например, "Писатели и читатели" - одновременно в библиотеке может быть либо писатели, которые
 * пишут книгу, либо читатели, которые читают книгу.
 * <p>
 * Рассмотрим одну из модификаций задачи "Producer-Consumer", суть которой будет заключаться в следующем: есть склад,
 * на который производители добавляют товары, а потребители берут товары. Потребитель может взять товар только при его
 * наличии на складе, то есть когда производитель его добавил. Здесь как раз могут пригодиться синхронизированные
 * методы:
 * <p>
 * Нередко работа одного потока зависит от другого. Например, есть классическая задача "Производители и потребители"
 * ("Producer-Consumer"), в которой производители производят товар и доставляют его в магазин, а потребители покупают
 * этот товар. При этом потребители могут купить товар только тогда, когда производители произвели этот товар. То есть
 * в данном случае есть потоки производителей и потоки потребителей, и они должны как-то взаимодействовать. Есть еще
 * ряд подобных задач, например, "Писатели и читатели" - одновременно в библиотеке может быть либо писатели, которые
 * пишут книгу, либо читатели, которые читают книгу.
 * <p>
 * Рассмотрим одну из модификаций задачи "Producer-Consumer", суть которой будет заключаться в следующем: есть склад,
 * на который производители добавляют товары, а потребители берут товары. Потребитель может взять товар только при его
 * наличии на складе, то есть когда производитель его добавил. Здесь как раз могут пригодиться синхронизированные
 * методы:
 */

/**
 * Нередко работа одного потока зависит от другого. Например, есть классическая задача "Производители и потребители"
 * ("Producer-Consumer"), в которой производители производят товар и доставляют его в магазин, а потребители покупают
 * этот товар. При этом потребители могут купить товар только тогда, когда производители произвели этот товар. То есть
 * в данном случае есть потоки производителей и потоки потребителей, и они должны как-то взаимодействовать. Есть еще
 * ряд подобных задач, например, "Писатели и читатели" - одновременно в библиотеке может быть либо писатели, которые
 * пишут книгу, либо читатели, которые читают книгу.
 *
 * Рассмотрим одну из модификаций задачи "Producer-Consumer", суть которой будет заключаться в следующем: есть склад,
 * на который производители добавляют товары, а потребители берут товары. Потребитель может взять товар только при его
 * наличии на складе, то есть когда производитель его добавил. Здесь как раз могут пригодиться синхронизированные
 * методы:
 */

/**
 * Производитель и покупатель по очереди захватывают монитор объекта Store, выполняя его метод put() или get().
 */

public class ProducerConsumerApp {

    public static void main(String[] args) {

        Store store = new Store();
        new Producer(store).start();
        new Consumer(store).start();
    }
}

